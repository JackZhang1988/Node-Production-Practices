#Node.js中的错误处理。

[TOC]

> 错误处理是一种痛苦，Node.js长久以来很容易无视而不处理。但是要想建立一个健壮的Node.js程序就必须正确的处理错误，而且这并不难学。如果你实在没耐心，那就直接绕过长篇大论跳到“总结”部分把。

[原文](https://www.joyent.com/developers/node/design/errors)

这篇文章会回答NodeJS初学者若干问题：

- 我的函数里，什么时候该抛出异常，什么时候该发送给callback, 又在什么时候触发eventEmitter，等等。
- 我的函数对参数该做出怎样的假设？我应该检查更加具体的约束么？比如检查参数是否非空，非负数，是不是看起来像个IP地址，等等等。
- 我该如何处理那些不符合函数预期的参数？我是应该抛出一个异常，还是把错误传递给一个回调函数。
- 我该怎么通过程序区分不同的异常？（比如“错误请求”和“服务不可用”）
- 我怎么才能提供足够的信息让调用着知道错误的细节。
- 我该怎么处理未预料的异常？我是应该用 `try/catch` ，domains 还是其它什么方式呢？

这篇文章可以划分成相互依赖的几个部分：
- **背景**：希望你已经具备的知识。
- **操作失败和程序员失误**：介绍两种基本的异常。
- **撰写函数的实践**：函数产生有用异常的基本原则。
- **编写新函数的具体推荐**：一个检查列表，包括具体如何编写一个产生有用异常的简装的函数。
- **例子**：文档和序言。
- **总结**：全文到此处的观点总结。
- **附录**：Error对象的约定属性，用标准的方式提供一个属性列表，以提供更多信息。

##背景

这篇文章假设：

- 你已经熟悉了异常的概念，JavaScript Java Python C++ 或者类似的语言。而且你知道抛出和捕获异常是什么意思。
- 你熟悉怎么用NodeJS编程。你能够很习惯的使用异步操作和callback(err,result)模式去完成异步操作。你得知道如下代码为什么不能正确处理异常。
```js
function myApiFunc(callback)
{
  /*
   * This pattern does NOT work!
   */
  try {
    doSomeAsynchronousOperation(function (err) {
      if (err)
        throw (err);
      /* continue as normal */
    });
  } catch (ex) {
    callback(ex);
  }
}
```

你还要熟悉三种传递异常的方式:
- 抛出一个异常。
- 把异常传给一个回调函数，这个函数正是为了处理异常和异步操作的。
- 在EventEmitter上触发一个Error事件。

接下来我们会详细讨论这几种方式。这篇文章假设你不知道任何关于domains的知识。

最后，你应该知道在JavaScript里，错误和异常是有区别的。错误是Error的一个实例。错误刻意被创建并且直接传递给另一个函数或者被抛出。如果一个错误被抛出了那么它就变成了一个异常。这是一个例子。
```js
throw new Error('something bad happened');
```
但是使用一个错误而不抛出也是可以的
```js
callback(new Error('something bad happened'));
```
这种用法更常见，因为在Nodejs里，大部分的错误都是异步的。实际上，`try/catch`唯一常用的地方是在`JSON.parse`和验证用户输入的时候。接下来我们会看到，其实很少要捕获一个异步函数里的异常。这一点和Java，C++，以及其它严重依赖异常的语言很不一样。

##操作失败和程序员的失误

把错误分成两大类很有用：

- **操作失败**: 正确编写的程序在运行时产生。它并不是程序的Bug，相反经常是其它问题：系统本身（内存不足或者打开文件数过多），系统配置（没有到达远程主机的路由），网络问题（端口挂起），远程服务（500错误，连接失败）。例子如下：
	- 连不到服务器
	- 无法解析主机域名
	- 无效的用户输入
	- 请求超时
	- 服务器返回500
	- 端口挂起
	- 系统内存不足

- **程序员的失误** 包括在程序里。这些错通过改变代码往往可以避免。他们没法被有效的处理。
	- 读取undefined的一个属性。
	- 调用异步函数没有指定回调。
	- 该传对象的时候传了一个字符串。
	- 该传IP地址的时候传递了一个对象。

人们总是用错误来吧运行错误和人的错混为一谈，但其实他们很不一样。运行错误是所有正确的程序应该处理的，只要被妥善处理，它们不一定会代表bug或是严重问题。“文件找不到”是一个运行错误，但是它不代表所有的事情都错了。它可能意味着程序如果想用一个文件得事先创建它。

与之相反，人的错是彻彻底底的Bug。这样的情形下你会犯错，忘记验证用户输入，敲错了一个变量名，诸如此类。这样的错误根本就没法处理，如果可以，那就意味着你用出错处理的函数代替了造成错误的那段代码。

这样的区分是很重要的：运行时错误是程序正常操作的一部分。而由人导致的错误则是Bug。

有的时候，你会在一个大问题里同时遇到运行错误和由人导致的错误。如果一个HTTP服务器尝试用一个未定义的变量，这是一个由人导致的错误。当前连接的客户端会在程序本亏的同一时间看到一个ECONNRESET错误，在NodeJS里一般会被报成“Socket Hang-up”。对客户端来说，这是一个无关的运行时错误。那是应为一个正确的客户端必须处理服务器挂机或者网络终端的情况。

类似的，如果没有处理好运行时错误，这本身就是一个失误。举个例子，如果一个程序想要连接服务器，但是得到一个ECONNREFUSED错误，恰好这个程序没有监听一个端口‘error’的事件，这便是一个失误。连接失败是一个程序错误（因为这是任何一个正确的程序在系统网络或者其它模块出问题时都会经历的），如果它不被正确处理，那它就是一个失误。

区分开运行错误和失误是搞清楚怎么传递异常和处理异常的基础。明白了这点再继续往下读。

###处理操作失败

就像性能和安全问题一样，异常处理并不是可以凭空加到一个没有任何异常处理的程序中的。你不能在一个集中的地方处理所有的异常，就像你不能在一个集中的地方解决所有的性能问题。你得考虑任何会导致失败的代码（比如打开文件，连接服务器，Fork子进程等）会产生的结果。包括为什么出错，错误背后的原因。待会会讲到，但是异常处理的关键在于粒度要细，因为哪里出错和为什么出错决定了影响和对策。

你可能会发现在栈的某几层不断地处理相同的异常。这是因为底层除了像上层传递错误，上层向它的上层传递错误以外，底层没有做任何有意义的事情。通常情况下，只有顶层的调用者知道正确的响应是什么，比如重试操作，报告给用户或者其它。但是那并不意味着，你应该把所有的错误全都丢给顶层的回调函数。因为，顶层的回调函数不知道发生错误的上下文，不知道那些操作已经成功执行，哪些操作实际上失败了。

我们来总结一下。对于一个给定的错误，你可以做这些事情。

- **直接处理异常**。处理错误有的时候很清楚该做什么。如果你在尝试打开一个日至文件的时候得到了一个ENOENT错误，很有可能你是第一次打开这个文件，你要做的就是首先创建它。一个更有意思的例子是，你维护了一个到服务器的持久连接（比如数据库），然后你的到了一个“套接字挂起”的异常。这通常意味着要么远端要么本地的网络失败了。很多时候这种错误是暂时的，所以大部分情况下你得重新连接来解决这个问题。（这和接下来的重试不大一样，因为在你得到这个错误的时候不一定有一个操作正在进行）

- **把错误扩散到客户端**。如果你不知道怎么处理这个异常，最好的方式就是放弃你真在做的操作，清理所有开始的，然后把错误传递给客户端。（怎么传递异常是另外一个问题了，接下会讨论）。这种方式适合错误短时间内无法解决的情形。比如，用户给了你一个不正确的JSON，你再解析一次是没什么帮助的。

- **重试操作**。对于那些来自网络和远程服务的错误，有的时候重试一个操作是有用的。比如，一个远程服务返回了一个503（服务不可用错误），你可能会在几秒种后重试。如果你要重试，你应该清晰的用文档记录下你要重试的次数，重试多少次直到失败，重试的间隔。和前面一样，你不应该假设每次都应该重试。如果这个程序在栈中很深的地方（比如，被一个客户端调用，而那个客户端被另外一个由用户操作的客户端控制），这种情形下快速失败让终端去重试更好。如果栈中的每一层都觉得需要重试，用户最终会等待更长的时间，因为每一层都没有意识到下层同时也在尝试。

- **自毁**。对于那些不可能发生的错误，或者代表失误的错误（比如无法连接到同一程序里一个本该在监听的本地套接字），记录一个错误消息或者崩溃是可以的。其它的错误比如内存不足，是一个像JavaScript这样的脚本语言无法处理的，崩溃是非常合理的。（即便如此，当在一个类似child_process.exec的分离操作里，得到一个ENOMEM错误，或者那些你可以合理处理的错误时，你可以这么做）在你无计可施需要让管理员做修复的时候，你也可以放弃。比如，你用完了所有的文件描述符或者没有访问配置文件的权限，这种情况下你什么都做不了，只能等某个用户登录系统把东西修好。

- **记录错误，其他什么都不做**。有的时候你什么都不用做，没有操作需要重试或者放弃，没有理由崩溃应用程序。有个例子是这样的，你用DNS跟踪了一组远程服务，结果有一个DNS失败了。除了记录一条日志并且使用剩下的服务继续以外，你什么都做不了。但是，你至少得记录点什么到日志里（凡事都有例外。如果这种情况每秒发生几千次，而你有什么都做不了，那每次发生都记录可能就不值得了。但是要周期性的记录）。

###（没有办法）处理程序员的失误

对于失误没有什么好做的。从定义上看，一段本该做事情的代码坏掉了（比如有一个变量名打错了），所以你不能用更多的代码去修复它。一旦你这样做了，你就使用错误处理的代码代替了错误代码。

有些人是赞成从失误中恢复的，也就是让当前的操作失败，但是继续处理请求。这种做法是不推荐的。考虑这样的情形，写原始代码的时候有一个失误是没考虑到某种情形。你怎么确定这个问题不会影响其他请求呢？如果其它的请求共享了某个状态（服务器，套接字，数据库连接池等），有极大的可能其他请求会做错误的事情。

一个典型的例子是REST服务器（比如用Restify搭），如果有一个请求处理函数抛出了一个ReferenceError（比如变量名打错）。有很可能继续运行下去会导致严重的Bug，而且极其难发现。例如：

1. 一些由请求共享的状态可能会被变成null，undefined或者其它的无效值，结果就是下一个请求也会失败。
2. 一个数据库连接可能会被泄露，拉低了能够并行处理的请求数。接下来可能会更糟糕，最后你只剩下几个可用连接，请求串行的到处理而不是并行。
3. 在更糟的情况下，一个postgres连接会被留在一次请求里。这回导致postgres“保有”表中某一行的旧值上因为对请求可见。这个问题会存在好几周，造成表无限制的增长，后续的请求都被拖慢了--从几毫秒到几分钟。虽然这个问题和postgres紧密相关，但是它很好的说明了一个简单地失误会让程序陷入一种非常可怕的状态。
4. 一个连接可能会被留在认证的状态，并且被后续的连接使用。一个请求可能会搞错用户。
5. 一个套接字可能会被打开着。一般情况下Node会在一个空闲的套接字上应用两分钟的超时，但这是可以覆盖的，结果就是泄露一个文件描述符。如果这种情况经常发生，你可能用完所有的描述符而奔溃。即使不覆盖这个超时时间，客户端会挂两分钟直到“挂起”错误的发生。这个两分钟的延迟会让问题非常难处理和调试。
6. 内存引用会被留下来。这会导致泄露，进而导致内纯耗尽，GC的时间拉长，最后性能急剧下降。这是非常难调试的，而且很需要技巧与导致造成泄露的失误联系起来。

**最好的从失误恢复的方法是立刻崩溃**。你应该用一个restarter来启动你的程序，在奔溃的时候自动重启。如果restarter准备就绪，崩溃是失误来临，最快的恢复可靠服务的方法。

奔溃应用程序会导致连接的客户端临时被扰乱，但是记住：

- 从定义上看，这些错误属于Bug。我们并不是在讨论执法系统或是网络错误，而是程序里实在的Bug。它们应该在产品里很罕见，并且有最高的优先级去调试和修复。
- 上面讨论的种种情形里，请求没有必要成功的完成。请求可能成功完成，可能让服务器再次崩溃，可能以某种明显的方式不正确的完成，或者以一种很难调试的方式错误的完成了/。
- 在一个完备的分布式系统力，客户端必须能够通过重连和重试来处理服务端的错误。不管NodeJS应用程序是否被允许崩溃，网络和系统的失败已经是一个事实了。

如果你的产品环境的应用如此频繁地崩溃，连接断开造成了问题，那么正真的问题是你的服务器Bug太多了，而不是一出Bug就奔溃。

如果服务器崩溃导致客户端不断地的断开是一个频繁的问题，你应该集中力在造成服务器崩溃的bug上面，把它们变成可捕获的异常，而不是在代码明显有问题的情况下尽可能地避免崩溃。最好的调试这类问题的方法是，把Node配置成出现未捕获异常时，把Core dump出来。在 GNU/Linux 和 基于illumos的系统上，你不经可以使用这些core文件来查看应用崩溃时的栈记录，还可以看到传递给函数的参数和其它的JavaScript对象，哪怕是在闭包里引用的。即使没有配置code dumps，你也可以用栈信息和日志来开始调查问题。

最后一点，记住服务器端的失误会造成客户端的运行错误。客户端必须处理好服务器端的奔溃和网络中断。这一点不只是理论，而是实际发生在线上环境里。

## 编写函数的实践

我们已经讨论了如何处理异常，那么当你在编写新的函数的时候。怎么才能向调用者传递错误呢？

最最重要的一点是为你的函数写好文档，包括它接受的参数（包含类型和其它约束），它的返回值，可能发生的错误，以及这些错误意味着什么。如果你不知道会导致什么错误或者不知道错误的含义，那你的应用程序如果正常工作就是一个巧合。所以，当你编写新的函数的时候，一定要告诉调用者可能发生哪些错误和错误的含义。

###Throw， Callback 还是 EventEmitter

函数有三种基本的传递错误的模式。

- `throw`以同步的方式传递异常--也就是在函数被调用的相同的上下文。如果调用者（或者调用者的调用者）用`try/catch`ch`，那么它们可以捕获异常。如果所有的调用者都没有，那么程序通常情况下会崩溃（异常可能会被domains或者进程级的”uncaughtException“捕捉到，后面会讲）。

- Callback是最基础的异步传递一个事件的方式。用户传递给你一个函数（callback），之后当某个异步操作完成后你调用这个callback。一般的模式是callback会以`callback(err,result)`的形式被调用，这种情况下， err和 result必然有一个是非空的，取决于操作是成功还是失败。

- 更复杂的情形是，没有用Callback，而是函数会返回一个EventEmitter对象，调用者需要监听这个对象的 error事件。这种方式在两种情况下很有用。

	- 当你在做一个有可能会导致多个错误和多个返回操作的时候。比如，有这样一个请求一边从数据库取数据一边把数据发送会客户端，而不是等待所有的结果一起到达。在这个例子里，没有用callback，而是返回了一个 EventEmitter，每个结果会触发一个 row 事件，当所有结果发送完毕后会触发一个end事件，出现错误时会触发一个error事件。

	- 用在那些复杂的状态机上，这些状态机往往伴随着大量的异步事件。例如，一个套接字是一个EventEmitter，它可能会触发“connect“，”end“，”timeout“，”drain“，”close“事件。很自然的，可以把”error“作为另外一种可以被触发的事件。在这种情况下，清楚知道”error“还有其它事件何时被触发很重要，同时被触发的还有什么事件（例如”close“），触发的顺序，套接字是否在结束的时候该关闭。

在大多数情况下，我们会把callback和event emitter归为“异步错误传递”之类。如果你又传递异步异常的需要，你通常只需要期中的一种而不是同时使用。

那么，什么时候用throw，什么时候用callback，什么时候又用EventEmitter呢？这取决于两件事：

- 这是一个操作失败还是程序员的失误？
- 这个函数本身是同步的还是异步的。

直到目前，最常见的例子是在异步函数里发生了操作失败。在大多数情况下，你需要写一个函数，并以一个回调函数作物参数，之后你会把异常传递给这个回调函数。这种方式工作的很好，并且被广泛使用。拿Node的FS模块举例子把。如果你的场景比上面这个还复杂，那么你可能就得换用EventEmitter了，即使这样你还是在用异步方式传递这个错误。

其次最常见的一个例子是像`JSON.parse`这样的函数同步产生了一个异常。对这些函数而言，如果遇到运行错误（比如无效输入），你得用同步的方式传递它。你可以抛出（更加常见）或者返回它。

对于一个给定的函数，如果有一个异步传递的异常，那么所有的异常都应该被异步传递。可能有这样的情况，请求到来你就知道它会失败，而且不是因为程序员的事务。可能的情形是你缓存了返回给最近请求的错误。即使你知道请求必定失败，但是你还是应该用异步的方式传递它。

通用的准则就是**你即可以同步传递异常（抛出），也可以异步传递异常（通过传给一个回调函数或者触发EventEmitter的error），但是不用同时使用**。以这种方式，用户处理异常的时候可以选择用回调函数还是用`try/catch`，但是不需要两种都用。具体用哪一个取决于异常是怎么传递的，这点得在文档里说明清楚。

差点忘了程序员的失误。回忆一下，它们其实是Bug。在函数开头通过检查参数的类型（或是其它约束）就可以被立即发现。一个退化的例子是，某人调用了一个异步的函数，但是没有传回调函数。你应该立刻把这个错抛出，因为程序已经出错而在这个点上最好的调试的机会就是得到一个堆栈信息，有core文件信息就更好了。

因为程序员的失误永远不应该被处理，上面提到的调用者只能用`try/catch`或者回调函数（或者EventEmitter）其中一种处理异常的准则并没有因为这条意见而改变。如果你想知道更多，请见上面的 （不要）处理程序员的失误。

这里对Node核心库的常见函数的例子做了一个总结，大致按照每种问题出现的频率来排列：

|Example func|Kind of func|Example error|Kind of error|How to deliver|Caller uses|
|---|
|`fs.stat`|asynchronous|file not found|operational|callback|handle|callback error|
|`JSON.parse`|synchronous|bad user input|operational|throw|`try/catch`|
|`fs.stat`|synchronous|null for filename|programmer|throw|none (crash)|


异步函数里出现操作错误的例子（第一行）是最常见的。在同步函数里使用操作失败（第二行）比较少见，除非是验证用户输入。程序员失误（第三行）除非开发，永远都不应该出现。

*吐槽：程序员失误还是操作失败？*

你怎么知道是程序员失误还是操作失败呢？很简单，你自己来定义并且记在文档里，包括允许什么类型的函数，怎样打断它们的执行。如果你得到的异常不是文档里能接受的，那就是一个程序员失误。如果在文档里写明接受但是暂时处理布料的，那就是一个操作失败。

你得用你的判断去决定你想做的多严格，但是我们会给你一些意见。更具体一些，想象有个函数叫做“connect”，它接受一个IP地址和一个回调函数作为参数，这个回调函数会在成功或者失败的时候被调用。现在假设用户传进来一个明显不是IP地址的参数，比如“bob”，这个时候你有几种选择：

- 在文档里写清楚之接受有效的ipv4的地址，在用户传进来“bob”的时候抛出一个异常。强烈推荐这种做法。
- 在文档写上接受任何string类型。如果用户传的是“bob”，触发一个异步错误指明无法连接到“bob”这个IP地址。

这两种方式和我们上面提到的关于操作失败和程序员失误的指导原则是相符的。你的确在决定这样的输入算是程序员的失误还是操作失败。通常，用户输入的检验是很松的，为了证明这点，可以看Date.parse这个例子，它接受很多类型的输入。但是对于大多数其它函数，我们强烈建议你偏向更严格而不是更松。你的程序越是尝试猜测用户的本意（使用隐式的转换，无论是JavaScript语言本身这么做还是有意为之），就越是容易猜错。本意是想节省用户得特别具体的麻烦，结果却耗费了程序员好几个小时用在debug上。再说了，如果你觉得这是个好主意，你也可以在未来的版本里让函数不那么严格，但是如果你发现由于猜测用户的意图导致了很多恼人的bug，要保持兼容性并且修复它就不大可能了。

所以如果一个值怎么都不可能是有效的（本该是string却得到一个undefined，本该是String型IP但明显不是），你应该在文档里写明是不允许的并且立刻抛出一个异常。只要你在文档里写的清清楚楚，那这就是一个程序员的失误而不是操作失败。立即抛出你可以把bug带来的损失降到最小，并且保存了开发者可以用来调试这个问题的信息（例如，调用堆栈，如果用core dumps还可以得到参数和内存分布）。

那么 `domains` 以及 `process.on('uncaughtException')` 呢？

操作失败总是可以被显示的机制所处理的：捕获一个异常，在回调里处理错误，或者处理EventEmitter的“error”事件等等。Domains以及进程级别的“uncaughtException”主要是用来从为预料的程序错误恢复的。由于上面我们所讨论的原因，这两种方式都不被鼓励。

## 编写新函数的具体建议

我们已经谈论了很多指导原则，现在让我们具体一些。

1. 你的函数做什么得很清楚。

	这点非常重要。每个接口函数的文档都要很清晰的说明：
	- 预期参数。
	- 每种参数的类型。
	- 参数额外的约束（例如，必须是有效的IP地址）

	如果有一点不正确或者缺少，那就是一个程序员的失误，你应该立刻抛出来。

	此外，你还要记录：

	- 调用者可能会遇到的操作失败（以及它们的名字）
	- 怎么处理操作失败（例如是抛出，传给回调函数，还是被EventEmitter发出）
	- 返回值。
	
2. 使用Error对象或它的子类，并且实现Error的协议。

	你的所有错误要么使用Error类要么使用它的子类。你应该提供name和message属性，stack也应该可用（注意准确）。

3. 在程序里通过 Error 的 name 属性 区分不同的错误。

	当你想要知道错误是何种类型的时候，用name属性。 JavaScript内置的你可能会想重用的名字包括“RangeError”（参数超出有效范围）和“TypeError”（参数类型错误）。而HTTP异常，通常会用RFC指定的名字，比如“BadRquestError”或者“ServiceUnavailableError”。

	不要想着给每个东西都取一个新的名字。如果你可以只用一个简单的InvalidArgumentError，就不要分成 InvalidHostnameError，InvalidIpAddressError，InvalidDnsError等等，你要做的是通过增加属性来说明那里出了问题（下面会讲到）。

4. 用详细的属性来增强Error对象。

	举个例子，如果一个参数是无效的，把 propertyName 设成参数的名字，把 propertyName 设成传进啦的值。如果无法连到服务器，用 remoteIp 属性指明尝试连接的 IP。如果得到一个系统异常，在 syscal 属性里存是哪个系统调用，并把系统异常的错误代码放到errno属性里。你可以查看附录，看有哪些样例属性可以用。

	不过你至少需要：

	`name`：用于在程序里区分众多的错误类型（例如参数非法和连接失败）

	`message`：一个供人阅读的错误消息。对可能读到这条消息的人来说这应该已经足够完整。如果你从更底层的地方传递了一个错误，你应该加上一些信息来说明你在做什么。想知道怎么包装异常请往下看。

	`stack`：一般来讲不要随意摆弄它。甚至不要增强它。V8引擎只有在这个属性被读的时候才会真的计算，可以在会在处理异常的时候显著提高性能。如果你读完再去增强它，结果就会多付出代价即使调用者并不需要堆栈信息。

	你还应该在错误信息里提供足够的消息，这样调用者不用分析你的错误就可以新建自己的错误。它们可能会本地化这个错误信息，也可能想要把大量的错误聚集到一起，再或者显示不同的错误信息（比如在网页上的一个表格里，或者高亮显示用户错误输入的字段）。

5. 若果你传递一个底层的错误给调用者，考虑先包装一下。

	你会经常发现一个异步函数funcA会调用另外一个异步函数funcB，如果funcB抛出了一个错误，你希望funcA也抛出一样。（请注意，第二部分并不总是跟在第一部分之后。有的时候funcA会重新尝试。有的时候你又希望funcA忽略错误因为无事可做。但在这里，我们只讨论funcA直接返回funcB错误的情况）

	在这个例子里，可以考虑包装这个错误而不是直接返回它。包装的意思是继续抛出一个包含底层信息的新的异常，并且带上当前层的上下文。用verror这个包可以很简单的做到。

	举个例子，假设有一个函数叫做 fetchConfig，这个函数会到一个远程的数据库取得服务器的配置。你可能会在服务器启动的时候调用这个函数。整个流程看起来是这样的：

	1.加载配置
	1.1 连接数据库。相应的
    1.1.1 解析数据库服务器的DNS主机名
	1.1.2 建立一个到数据库服务器的TCP连接
	1.1.3 向数据库服务器认证
	1.2 发送DB请求
	1.3 解析返回值
	1.4 加载配置
	2 开始处理请求

	假设在运行的时候除了一个问题连接不到数据库服务器。如果连接在1.1.2的时候因为没有到主机的路由而失败了，每个层都不加处理地都把异常向上抛出给调用者。你可能会看到这样的异常信息：
	```sh
	myserver: Error: connect ECONNREFUSED。
	```
	这显然是没有很大用处的。

	另一方面，如果每一层都把下一层返回的异常包装一下，你可以得到更多的信息：
	```sh
	myserver: failed to start up: failed to load configuration: failed to connect to database server: failed to connect to 127.0.0.1 port 1234: connect ECONNREFUSED。
	```
	你可以会想跳过几层的封装来得到一条不那么充满学究气息的消息：
	```sh
	myserver: failed to load configuration: connection refused from database at 127.0.0.1 port 1234.
	```
	另一方面，报错的时候详细一点总比很信息少要好。

	如果你决定封装一个异常，有几件事情要考虑：

	- 保持原有的异常完整不变，保证当调用者想要直接用的时候底层的异常还可用。

	- 要么用原有的名字，要么显示地选择一个更有意义的名字。例如，最底层是Node的一个简单的Error，但是步骤1的可能是个IntializationError。（但是如果程序可以通过其它的属性区分，不要觉得有责任取一个新的名字）

	- 保留原有错误的所有属性。在合适的情况下增强message属性（但是不要在原始的异常上修改）。浅拷贝其他的像是syscall，errno这类的属性。最好是直接拷贝除了 name，message和stack以外的所有属性，而不是硬编码一个需要拷贝的属性列表。不要理会stack，因为即使是读取它也是相对昂贵的。如果调用者想要一个合并后的堆栈，它应该遍历错误原因并打印每一个的堆栈。

	在Joyent，我们使用verror这个包封装异常因为它的语法简洁。写这篇文章的时候，它还不能支持上面的所有功能，但是会被扩展以期支持。

##例子

考虑有这样的一个函数，它会异步地连接到一个IPv4地址的TCP端口。我们通过例子来看文档怎么写：

```js
/*
 * Make a TCP connection to the given IPv4 address.  Arguments:
 *
 *    ip4addr        a string representing a valid IPv4 address
 *
 *    tcpPort        a positive integer representing a valid TCP port
 *
 *    timeout        a positive integer denoting the number of milliseconds
 *                   to wait for a response from the remote server before
 *                   considering the connection to have failed.
 *
 *    callback       invoked when the connection succeeds or fails.  Upon
 *                   success, callback is invoked as callback(null, socket),
 *                   where `socket` is a Node net.Socket object.  Upon failure,
 *                   callback is invoked as callback(err) instead.
 *
 * This function may fail for several reasons:
 *
 *    SystemError    For "connection refused" and "host unreachable" and other
 *                   errors returned by the connect(2) system call.  For these
 *                   errors, err.errno will be set to the actual errno symbolic
 *                   name.
 *
 *    TimeoutError   Emitted if "timeout" milliseconds elapse without
 *                   successfully completing the connection.
 *
 * All errors will have the conventional "remoteIp" and "remotePort" properties.
 * After any error, any socket that was created will be closed.
 */
function connect(ip4addr, tcpPort, timeout, callback)
{
  assert.equal(typeof (ip4addr), 'string',
      "argument 'ip4addr' must be a string");
  assert.ok(net.isIPv4(ip4addr),
      "argument 'ip4addr' must be a valid IPv4 address");
  assert.equal(typeof (tcpPort), 'number',
      "argument 'tcpPort' must be a number");
  assert.ok(!isNaN(tcpPort) && tcpPort > 0 && tcpPort < 65536,
      "argument 'tcpPort' must be a positive integer between 1 and 65535");
  assert.equal(typeof (timeout), 'number',
      "argument 'timeout' must be a number");
  assert.ok(!isNaN(timeout) && timeout > 0,
      "argument 'timeout' must be a positive integer");
  assert.equal(typeof (callback), 'function');

  /* do work */
}
```

这个例子概念上很简单，但是印证了上面我们谈论的一些建议：

- 参数，类型以及其它一些约束被清晰的文档化。

- 这个函数对于接受的参数是非常严格的，并且会在得到错误参数的时候抛出异常（程序员的失误）。

- 可能出现的操作失败集合被记录了。通过不同的”name“可以区分不同的异常，而”errno“被用来获得系统错误的详细信息。

- 异常被传递的方式也被记录了（通过失败时调用回调函数）。

- 返回的错误有”remoteIp“和”remotePort“字段，这样用户就可以定义自己的错误了（比如，端口号是暗含的，因为这是一个HTTP客户端）。

- 虽然很明显，但是连接失败后的状态也被清晰的记录了：所有被打开的套接字此时已经被关闭。

这看起来像是给一个很容易理解的函数写了超过大部分人的超长注释，但实际上大部分函数没有这么容易理解。所有的建议都应该被批判的吸收，当事情很简单的时候你应该自己做出判断，但是记住：用十分钟把预计发生的记录下来可能之后会为你或其他人节省几个小时。

##总结

- 学会怎么区分操作失败，哪些是可以预测的，哪些是无法避免的哪怕在正确的程序里（例如，无法连接到服务器）；程序员失误其实是程序的Bug。

- 操作失败可以也应该被处理。程序员的失误无法被处理和可靠地恢复（就不该这样），尝试这么做只会让问题更难调试。

- 一个给定的函数，它处理异常的方式要么是同步（用throw方式）要么是异步的（用回调函数或者EventEmitter），但是不应该两种混用。用户可以在回调函数里使用 `try/catch` ，但是不能一起用。实际上，即用throw又期望 调用者使用 `try/catch` 是很罕见的，因为在 Node.js 里同步函数不是经常抛出异常（主要的例外是类似于`JSON.parse`的用户输入验证函数）。

- 在写新函数的时候，用文档清楚地记录函数预期的参数，包括它们的类型、其它约束（例如必须是有效的IP地址），可能互发生的合理的操作失败（例如无法解析主机名，连接服务器失败，所有的服务器端错误），错误是怎么传递给调用者的（同步的用throw，还是异步的用回调函数和EventEmitter）。

- 丢失或者不合理的参数是程序员失误，发生的时候你应该抛出异常。作者认为的可接受的参数可能会有一个灰色地带，但是如果传的是一个文档里接收参数以外的东西，那就是一个程序员失误。

- 传递错误的时候用标准的Error类和它标准的属性。尽可能的把我额外的有用信息放在其它属性里。如果有可能，用约定的属性名（如下）。

#附录：Error对象属性命名约定

强烈建议你在发生错误的时候用这些名字来保持和Node核心以及Node插件的一致。这些大部分不会和某个给定的异常对应，但是出现疑问的时候，你应该包含任何看起来有用的信息，即从编程上也从自定义的错误消息上。【表】。

|Property name |	Intended use	|
|-------------:|:-------------------|
|localHostname| 	the local DNS hostname (e.g., that you're accepting connections at)|
|localIp| 			the local IP address (e.g., that you're accepting connections at)|
|localPort| 		the local TCP port (e.g., that you're accepting connections at)|
|remoteHostname| 	the DNS hostname of some other service (e.g., that you tried to connect to)|
|remoteIp| 			the IP address of some other service (e.g., that you tried to connect to)|
|remotePort |		the port of some other service (e.g., that you tried to connect to)|
|path| 				the name of a file, directory, or Unix Domain Socket (e.g., that you tried to open)|
|srcpath |			the name of a path used as a source (e.g., for a rename or copy)|
|dstpath |			the name of a path used as a destination (e.g., for a rename or copy)|
|hostname| 			a DNS hostname (e.g., that you tried to resolve)|
|ip| 				an IP address (e.g., that you tried to reverse-resolve)|
|propertyName|	 	an object property name, or an argument name (e.g., for a validation error)|
|propertyValue|	 	an object property value (e.g., for a validation error)|
|syscall| 			the name of a system call that failed|
|errno| 			the symbolic value of errno (e.g., "ENOENT"). Do not use this for errors that don't actually set the C value of errno.Use "name" to distinguish between types of errors.|

##脚注

1. 人们有的时候会这么写代码，当他们想要在出现异步错误的时候，调用callback并把错误作为参数传递过去。但是他们犯了一个错误，以为在他们自己的回调函数（传递给doSomeAsynchronousOperation的函数）里throw一个异常，会被外面的catch代码块捕获。`try/catch`和异步函数不是这么工作的。回忆一下，异步函数的意义就在于被调用的时候myApiFunc函数已经返回了。这意味着try代码块已经退出了。这个回调函数是由Node直接调用的，外面并没有try的代码块。如果你用这个反模式，结果就是抛出异常的时候，程序崩溃了。

2. 在JavaScript里，抛出一个不属于Error的参数从技术上是可行的，但是应该被避免。这样的结果使获得调用堆栈没有可能，代码也无法检查”name“属性，或者其它任何能够说明哪里有问题的属性。

3. 操作失败和程序员的失误这一概念早在NodeJS之前就已经存在存在了。不严格地对应者Java里的checked和unchecked异常，虽然操作失败被认为是无法避免的，比如 OutOfMemeoryError，被归为uncheked异常。在C语言里有对应的概念，普通异常处理和使用断言。维基百科上关于断言的的文章也有关于什么时候用断言什么时候用普通的错误处理的类似的解释。

4. 如果这看起来非常具体，那是因为我们在产品环境中遇到这样过这样的问题。这真的很可怕。
